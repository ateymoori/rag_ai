Principles of Security — SBAB Docs  documentation SBAB Docs Ansible Controller Ansible Roles Ansible Vault Argo Workflows Authentication & Authorization Bitbucket Boost Chatbot Booli Ceph Dex Fortigate troubleshooting Generate certificate Go GitHub Copilot GitLab @Sbab User Guide GitLab Maintenance Grafana Istio Java Jenkins Jenkinsfile Jmeter Kafka Maintenance Kafka @Sbab User Guide Kafka Connect Kubectl Access Kubernetes Lab environment Local Open Web Metrics infrastructure MongoDB Netbox NVIDIA Neo4J Sonatype Nexus repository Oracle OWASP Database OWASP @Sbab User Guide Pact Principles of Security Introduction Defense in Depth Fail Safe Least Privilege Separation of Duties Economy of Mechanism Complete Mediation Open Design Least Common Mechanism Psychological Acceptability Weakest Link Leveraging Existing Components Prometheus ReactJS Redis Renovate S3 Security Guidelines for Developers Sentry Maintenance Sentry User Guide Configuring Variables for Services Deployed to Kubernetes Software Architecture SonarQube Maintenance SonarQube User Guide Structurizr System Landscape Vagrant Zipkin Windows Pipelines SBAB Docs » Principles of Security View page source Principles of Security ï Introduction Defense in Depth Fail Safe Least Privilege Separation of Duties Economy of Mechanism Complete Mediation Open Design Least Common Mechanism Psychological Acceptability Weakest Link Leveraging Existing Components Introduction ï As each development team is responsible for the security of their respective applications and services, itâs important for these teams to have a basic understanding of secure design principles. Security by Design is a widely accepted approach to ensure the safety and privacy of applications and services. It involves integrating security into the design right from the start to make it inherently secure. The design choices are based on proven security methods that address both known and potential vulnerabilities. These principles help ensure that the application or service can maintain important security features like authentication, encryption and logging even when itâs under attack. Defense in Depth ï This principle involves building multiple layers of security that back each other up. It aims to create redundancy in security, so if one layer is breached, other layers can still provide protection. These layers can include firewalls, encryption, access control, input validation etc. As a developer you usually focus on the two innermost layers (âAppâ and âDataâ). Keep in mind that these layers, in turn, can be divided into sub layers such as authentication, authorization and session management. Try to consider the entire chain. Even if you only work with certain layers, you might know which security measures are appropriate to implement. Build defenses in multiple layers that back each other up. Expect that some defenses might fail and design your defense accordingly. Fail Safe ï This principle aims to maintain confidentiality, integrity, and availability when an error occurs. Errors may be the result of an attack, or due to design or implementation failures. In the event of an unexpected failure, the application or service should default to a secure state (rather than an unsafe state). Example ï isAdmin = true;
try {
    isAdmin = isUserInRole(âAdministratorâ);
}
catch (Exception ex)
{
    log.write(ex.toString());
} This code checks if a user has the âAdministratorâ role and set the âisAdminâ flag accordingly. However, it has some issues from a security and fail-safe perspective: If âisUserInRoleâ fails, the user is an admin by default. This is obviously a security risk. The code logs the exception string. This might include sensitive information or details about the environment. Itâs better to log specific information about the error. Deny by default. Design applications and services to fail safe, meaning that when they fail, they fail âclosedâ (e.g., denying access). Least Privilege ï Means that a person or process is given the minimum level of privileges necessary to complete an assigned operation. Also, the privileges should only be given for the minimum amount of time required to complete the operation. The principle of least privilege reduces the risk of data breaches and unauthorized access to critical applications or services. Limits the damage in case of an exploited vulnerability. To apply this principle, proper granularity of privileges and permissions should be established. Separation of Duties ï Also known as âseparation of privilegesâ. This principle aims to divide the responsibilities and functions of an application or service into dedicated and isolated components. This separation helps improve maintainability, scalability, and security. Dividing applications and services into isolated components with limited privileges makes it more difficult for an exploit of a single process to access other processes and data. No one person or component should have access to all elements of an application or service. Applications and services should be designed so that multiple components are required for completion, especially those dealing with financial transactions or those handling sensitive information. Economy of Mechanism ï Also known as âkeep it simpleâ. Most applications and services work best if they are kept simple rather than made complicated. Complex designs are more likely to have vulnerabilities, especially when their code is difficult to understand and review. Keep designs as simple and small as possible. Reduce the number of components used, delete unnecessary functions and retaining only those that are essential. Simplicity in design, particularly for essential security mechanisms, makes it easier to analyze and reduces the likelihood of errors. Complete Mediation ï Every access to a resource or action should be checked for authorization at the time it is requested, and the access should only be granted if the user or component has the necessary permissions. In simpler terms, it means that every time someone wants to access something, the system makes sure they have the right permissions, leaving no room for unauthorized access. Results of authorization are often cached. What if the permissions changed since last check? For each access to every object, verify proper authorization. Verifying authorization requires authentication, checking that the associated user or component is authorized and checking that the request has integrity. Each time the subject tries to interact with an object it should be checked again and not cached. Open Design ï Do not rely on secret designs, attacker ignorance or security by obscurity. Invite and encourage open review and analysis. There should be sufficient security controls in place to keep your application or service safe without hiding core functionality or source code. Security through obscurity is not security! Least Common Mechanism ï This principle aims to minimize the use of shared resources to limit the potential for unauthorized access or data leaks. When different users or processes use the same mechanism, such as a library or a database, a security breach in one area can spread to others. By minimizing shared mechanisms, you decrease the chances of a domino effect of security failures. For example, say that several microservices need to communicate with a database. Following the principle of âLeveraging Existing Componentsâ, they should use shared modules that are tried and tested. However, they should still use separate system accounts, making it easier to allow (or deny) each service the appropriate permissions. Psychological Acceptability ï This security principle focuses on making security features in software easy to use and transparent to the user. If security features are cumbersome or complex, users may seek ways to bypass them, thereby defeating the purpose of having security in the first place. You should aim to strike a balance between robust security and user convenience. Security mechanisms should not make the resource more difficult to access than if the security mechanism were not present. Weakest Link ï The weakest link principle means that an application or serviceâs security is only as strong as its weakest part. Strengthening the most vulnerable component is crucial because attackers often target the weakest point to breach the entire system, be it the code, system configuration or environment. Leveraging Existing Components ï This security principle focuses on reducing the risk of attacks and new vulnerabilities. It achieves this by promoting the reuse of existing software components, code, and functionality. Existing components are more likely to be tried and tested, and hence more secure. At SBAB, we maintain a collection of shared libraries designed to increase security and maintain code consistency across projects. The libraries are maintained by the Technical Architecture Forum ( https://gitlab.sbab.se/tech-arch-forum/ ), but all developers are encouraged to contribute suggestions and feedback. These libraries should always be considered when implementing security functionality. They include essential functions such as: Authentication Tracing Logging Health check Common configurations Feel free to explore and leverage these resources to streamline your project development and ensure adherence to best practices. If you encounter missing functionality, or have any questions regarding these libraries, please contact the Technical Architecture Forum via Slack (#forum-technical-architecture). Leverage vetted modules or services for application security components, such as identity management, encryption, and auditing and logging. Using platform features in critical security functions will reduce developersâ workload and minimize the likelihood of design or implementation errors. Previous Next © Copyright 2024, TNT. Built with Sphinx using a theme provided by Read the Docs .